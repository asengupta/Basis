**NOTE: Starting from version 0.5.1, Basis has been ported to Ruby 1.9.2, because of the kd-tree library dependency. Currently, there are no plans of maintaining Basis compatibility with Ruby 1.8.x.**

**Basis** provides a set of classes for easily plotting and transforming arbitrary 2D coordinate systems by specifying their basis vectors. Originally developed to work with Ruby-Processing, it now supports any class which supports Processing-like semantics.

Starting from version 0.5.0, experimental support has been added for mouseover interactivity without (too much) extra effort on your part. This is still a work in progress, though.

## Installation

To install the Basis gem, first head to the location where the jruby-complete.jar is located, for Ruby-Processing. There, do this:

    java -jar jruby-complete.jar -S gem install basis-processing --user-install

Alternatively, if you're using a conventional JRuby installation, do this:

    sudo jruby -S gem install basis-processing

To use Basis functionality in your code, it is enough to:

    require 'basis_processing'

## Example Code

Here's some example code, which plots random points.

	require 'rubygems'

	Gem.clear_paths
	ENV['GEM_HOME'] = '/home/avishek/jruby/jruby-1.6.4/lib/ruby/gems/1.8'
	ENV['GEM_PATH'] = '/home/avishek/jruby/jruby-1.6.4/lib/ruby/gems/1.8'

	require 'basis_processing'

	class Demo < Processing::App
		app = self
		def setup
			render_mode(P2D)
			no_loop
			background(0,0,0)
			color_mode(RGB, 1.0)
			stroke(1,1,0,1)
			@highlight_block = lambda do |original, mapped, s|
						s.in_basis do
							rect_mode(CENTER)
							stroke(1,0,0)
							fill(1,0,0)
							rect(original[:x], original[:y], 3, 3)
						end
					   end

			points = []
			200.times {|n|points << {:x => n, :y => random(300)}}

	#		Long-winded way of setting up a coordinate system explicitly

	#		@x_unit_vector = {:x => 1.0, :y => 0.0}
	#		@y_unit_vector = {:x => 0.0, :y => 1.0}
	#		x_range = ContinuousRange.new({:minimum => 0, :maximum => 200})
	#		y_range = ContinuousRange.new({:minimum => 0, :maximum => 300})
	#		@basis = CoordinateSystem.new(Axis.new(@x_unit_vector,x_range), Axis.new(@y_unit_vector,y_range), self, [[1,0],[0,1]])

	#		Accomplish the above in a single line below...
			@basis = CoordinateSystem.standard({:minimum => 0, :maximum => 200}, {:minimum => 0, :maximum => 300}, self)

			screen_transform = Transform.new({:x => 2, :y => -2}, {:x => 300, :y => 900})
			@screen = Screen.new(screen_transform, self, @basis)
			@screen.draw_axes(10,10)
			stroke(1,1,0,1)
			fill(1,1,0)
			rect_mode(CENTER)
			points.each do |p|
				@screen.plot(p, :track => true) do |original, mapped, s|
					s.in_basis do
						rect(original[:x], original[:y], 3, 3)
					end
				end
			end
		end
	
		def draw
		end
	end

	w = 1200
	h = 1000

	Demo.send :include, Interactive
	Demo.new(:title => "My Sketch", :width => w, :height => h)

You have a few options when plotting a point. If you specify ':bar => true', like the line below:

	screen.plot(p, basis, :bar => true) {|p| rect(p[:x], p[:y], 5, 5)}

it will connect the point with the x-axis. If you omit `:bar => true` or don't specify any options, Basis will plot the points without connecting them to the X-axis.

If you omit the block at the end of the call, Basis will plot the point using a circle. Use the block to customise how you wish to represent the point graphically.

You can toggle the joining of the points with lines by setting the join attribute of Screen to on (joins points)/off (no joining). The default is false.

You have more options for drawing objects on screen, either in the default basis (sans any transformation), or in the basis you've specified. If you're using your specified basis, all shapes you draw (rectangles, ellipses, etc.) will be draw as they'd appear in the custom basis.

For example, in the code below, we are specifying that all our drawing (in this case, a filled rectangle) will be drawn using the basis specified while defining the Screen object.

			@highlight_block = lambda do |original, mapped, s|
						s.in_basis do
							rect_mode(CENTER)
							stroke(1,0,0)
							fill(1,0,0)
							rect(original[:x], original[:y], 3, 3)
						end
					   end

Of course, in this case, the basis vectors are the standard ones, so you'll not really notice anything. But let's consider the follwing example.

	require 'rubygems'

	Gem.clear_paths
	ENV['GEM_HOME'] = '/home/avishek/jruby/jruby-1.6.4/lib/ruby/gems/1.8'
	ENV['GEM_PATH'] = '/home/avishek/jruby/jruby-1.6.4/lib/ruby/gems/1.8'

	require 'basis_processing'

	class Demo < Processing::App
		app = self
		def setup
			render_mode(P2D)
			no_loop
			background(0,0,0)
			color_mode(RGB, 1.0)
			stroke(1,1,0,1)
			@highlight_block = lambda do |original, mapped, s|
						s.in_basis do
							rect_mode(CENTER)
							stroke(1,0,0)
							fill(1,0,0)
							rect(original[:x], original[:y], 3, 3)
						end
					   end

			points = []
			200.times {|n|points << {:x => n, :y => random(300)}}

			@x_unit_vector = {:x => 1.0, :y => 1.0}
			@y_unit_vector = {:x => -1.0, :y => 1.0}
			x_range = ContinuousRange.new({:minimum => 0, :maximum => 200})
			y_range = ContinuousRange.new({:minimum => 0, :maximum => 300})
			@basis = CoordinateSystem.new(Axis.new(@x_unit_vector,x_range), Axis.new(@y_unit_vector,y_range), self, [[1,0],[0,1]])

			screen_transform = Transform.new({:x => 2, :y => -2}, {:x => 300, :y => 900})
			@screen = Screen.new(screen_transform, self, @basis)
			@screen.draw_axes(10,10)
			stroke(1,1,0,1)
			fill(1,1,0)
			rect_mode(CENTER)
			points.each do |p|
				@screen.plot(p, :track => true) do |original, mapped, s|
					s.in_basis do
						rect(original[:x], original[:y], 3, 3)
					end
				end
			end
		end
	
		def draw
		end
	end

	w = 1200
	h = 1000

	Demo.send :include, Interactive
	Demo.new(:title => "My Sketch", :width => w, :height => h)

In the above code, the basis vectors are (1,1) and (-1,1). The @highlight_block is the same as in the previous example. But if you run the above example, the highlighted rectangle will also appear rotated. Contrast this with an alternate definition of @highlight_block, like so:

		@highlight_block = lambda do |original, mapped, s|
					s.outside_basis do
						rect_mode(CENTER)
						stroke(1,0,0)
						fill(1,0,0)
						rect(mapped[:x], mapped[:y], 3, 3)
					end
				   end

This will draw the highlighted rectangle unrotated. You can make use of the in_basis() and the outside_basis() methods to use one or the other. The default is to draw it in the default, untransformed, basis. For your convenience, the first two parameters passed to your block will be the original, and the mapped points, respectively.

## Convenience methods for setting up default CoordinateSystem

If you're doing a simple plot, with standard basis vectors with no transformations, you can use the convenience method in CoordinateSystem to set up a default system.

		@basis = CoordinateSystem.standard({:minimum => 0, :maximum => 200}, {:minimum => 0, :maximum => 300}, self)
If you want more control over your transformations and/or are using custom (possibly non-perpendicular) basis vectors, you'll want to specify all of that explicitly. In the example below, we are setting up a CoordinateSystem with basis vectors (1,1) and (-1,1), with a nonuniform scaling transformation ((2,0),(0,3)).

		@x_unit_vector = {:x => 1.0, :y => 1.0}
		@y_unit_vector = {:x => -1.0, :y => 1.0}
		x_range = ContinuousRange.new({:minimum => 0, :maximum => 200})
		y_range = ContinuousRange.new({:minimum => 0, :maximum => 300})
		@basis = CoordinateSystem.new(Axis.new(@x_unit_vector,x_range), Axis.new(@y_unit_vector,y_range), [[2,0],[0,3]], self)


## Running the Code (with extra notes for versions >= 0.5.1)

Running the code is as simple as typing:

`rp5 run demo.rb`

If you're not using the Gems-in-a-Jar approach, you might have to use:

`rp5 run --jruby demo.rb`

The reason for the `--jruby` switch is to force Ruby-Processing to use the installed version of JRuby, instead of it's own jruby-complete.jar

Additionally, starting with version 0.5.1, you will have to specify the environment variable JRUBY_OPTS to force JRuby to use the 1.9 version of the interpreter, like so:

`export JRUBY_OPTS=--1.9`

## Notes on Interactivity

Experimental support exists for mouseover interactivity without (too much) extra effort on your part. To allow interactions to happen, you must specify ':track => true' while plotting a point, as in the line below:

	@screen.plot(p, :track => true) {|p| rect(p[:x], p[:y], 5, 5)}

To actually enable interactivity, you must do a few things:

* 'include' the Interactive module in your sketch class, as in the demonstration code above, namely the line `Demo.send :include, Interactive`
* `@highlight_block` specifies what to plot when the data point is hovered upon.

Interactivity is a work in progress at the moment; some of the above steps may change or be removed.

